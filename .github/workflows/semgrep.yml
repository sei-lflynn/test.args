# Semgrep (hardened, pinned, least-privilege) — PRs, pushes, manual, nightly
# =============================================================================
# What this workflow does (high level):
#   1) Job "semgrep-scan": installs a pinned Semgrep CLI and runs a scan that
#      always writes SARIF (semgrep.sarif). If a Semgrep App token is present,
#      it uses `semgrep ci` (org policies). Otherwise it uses `semgrep scan`
#      with curated registry rules (`p/ci`). It saves SARIF as an artifact.
#   2) Job "upload-sarif": uploads the SARIF to GitHub Code Scanning.
#
# Why this structure:
#   • Separate jobs: only the uploader gets `security-events: write` (least privilege).
#   • Everything is pinned to commit SHAs for reproducibility and tamper resistance.
#   • Concurrency + timeouts: prevent CI pile-ups and cap spend.
#   • Egress hardening: start in audit; later flip to block + allowlist.
#   • No `latest` containers; we pin Semgrep via pip to a fixed version.

name: Semgrep

on:
  workflow_dispatch: {}
  pull_request:
    branches: [ "main" ]
    paths:
      - "**/*"
      - ".github/workflows/semgrep.yml"
  push:
    branches: [ "main" ]
    paths:
      - "**/*"
      - ".github/workflows/semgrep.yml"
  schedule:
    - cron: "16 6 * * *"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  semgrep-scan:
    name: Semgrep scan → SARIF
    runs-on: ubuntu-24.04
    timeout-minutes: 20
    permissions:
      contents: read
    env:
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
      SEMGREP_VERSION: "1.134.0"
      SARIF_FILE: "semgrep.sarif"
      SARIF_ENRICHED_FILE: "semgrep.cwe-tagged.sarif"
    outputs:
      has_sarif: ${{ steps.check.outputs.has_sarif }}

    steps:
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0

      - name: Set up Python (exact patch)
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.12.5"

      - name: Install Semgrep CLI (hash-locked; sdist-safe, two-phase)
        shell: bash
        env:
          PIP_DISABLE_PIP_VERSION_CHECK: "1"
          PIP_INDEX_URL: "https://pypi.org/simple"
        run: |
          set -euo pipefail
          tmp="$(mktemp -d)"
          python -m pip download -d "$tmp" "semgrep==${SEMGREP_VERSION}" "setuptools" "wheel"
          build="$tmp/build-req.txt"; : > "$build"
          main="$tmp/main-req.txt";  : > "$main"
          for n in setuptools wheel; do
            f="$(ls -1 "$tmp"/$n-*.whl 2>/dev/null | sort | tail -n1 || true)"
            if [ -n "$f" ]; then
              h="$(sha256sum "$f" | awk '{print $1}')"
              printf 'file://%s --hash=sha256:%s\n' "$f" "$h" >> "$build"
            fi
          done
          while IFS= read -r f; do
            base="$(basename "$f")"
            case "$base" in setuptools-*.whl|wheel-*.whl) continue;; esac
            h="$(sha256sum "$f" | awk '{print $1}')"
            printf 'file://%s --hash=sha256:%s\n' "$f" "$h" >> "$main"
          done < <(find "$tmp" -maxdepth 1 -type f \( -name '*.whl' -o -name '*.tar.gz' -o -name '*.zip' \) | sort)
          if [ -s "$build" ]; then
            python -m pip install --no-index --require-hashes -r "$build"
          fi
          python -m pip install --no-index --require-hashes --no-build-isolation -r "$main"
          semgrep --version
        timeout-minutes: 10

      - name: Determine baseline commit (PRs only)
        id: base
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch --no-tags origin "${{ github.event.pull_request.base.ref }}":"refs/remotes/origin/${{ github.event.pull_request.base.ref }}" || true
            mb="$(git merge-base "HEAD" "refs/remotes/origin/${{ github.event.pull_request.base.ref }}")" || mb=""
            echo "baseline=${mb}" >> "$GITHUB_OUTPUT"
          else
            echo "baseline=" >> "$GITHUB_OUTPUT"
          fi

      # ✅ One format only: SARIF
      - name: Run Semgrep (CI or CE) → SARIF
        shell: bash
        env:
          SEMGREP_BASELINE_COMMIT: ${{ steps.base.outputs.baseline }}
        run: |
          set -euo pipefail
          if [[ -n "${SEMGREP_APP_TOKEN:-}" ]]; then
            semgrep ci --sarif --output "${SARIF_FILE}"
          else
            semgrep scan --config auto \
              --config p/owasp-top-ten \
              --config p/cwe-top-25 \
              --config p/security-audit \
              --config p/secrets \
              --timeout=30 \
              --timeout-threshold=0 \
              --max-target-bytes=0 \
              --dataflow-traces \
              --sarif --output "${SARIF_FILE}"
          fi

      # ✅ Convert existing SARIF CWE tags to GitHub's taxonomy tags (no filename inference)
      - name: Enrich SARIF with CWE tags (Semgrep SARIF → external/cwe/cwe-###)
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          import json, re, os
          src = os.environ.get("SARIF_FILE", "semgrep.sarif")
          dst = os.environ.get("SARIF_ENRICHED_FILE", "semgrep.cwe-tagged.sarif")
          with open(src, "r", encoding="utf-8") as f:
              sarif = json.load(f)

          for run in sarif.get("runs", []):
              tool = (run.get("tool") or {}).get("driver") or {}
              for rule in tool.get("rules", []) or []:
                  props = rule.setdefault("properties", {})
                  tags = set(props.get("tags", []))
                  # Find CWE numbers in existing tags like "CWE-250: ..." or "CWE-079"
                  cwes = set()
                  for t in list(tags):
                      m = re.search(r"\bCWE-?(\d{1,4})\b", t, flags=re.IGNORECASE)
                      if m:
                          cwes.add(int(m.group(1)))
                  # Add GitHub-style taxonomy tags
                  for n in sorted(cwes):
                      tags.add(f"external/cwe/cwe-{n:03d}")
                  props["tags"] = sorted(tags)

          with open(dst, "w", encoding="utf-8") as f:
              json.dump(sarif, f, indent=2)
          PY

      - name: Check SARIF exists
        id: check
        shell: bash
        run: |
          set -euo pipefail
          if [[ -s "${SARIF_ENRICHED_FILE}" ]]; then
            echo "has_sarif=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_sarif=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload SARIF as artifact
        if: always() && steps.check.outputs.has_sarif == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: semgrep-sarif
          path: ${{ env.SARIF_ENRICHED_FILE }}
          retention-days: 14

  upload-sarif:
    name: Upload SARIF to Code Scanning
    needs: semgrep-scan
    if: ${{ needs.semgrep-scan.outputs.has_sarif == 'true' }}
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      - name: Download SARIF artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: semgrep-sarif
          path: .

      - name: Upload SARIF to GitHub Security Dashboard
        uses: github/codeql-action/upload-sarif@3c3833e0f8c1c83d449a7478aa59c036a9165498 # v3.29.11
        with:
          sarif_file: semgrep.cwe-tagged.sarif
          category: semgrep
